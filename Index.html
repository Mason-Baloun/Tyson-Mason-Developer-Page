<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Isomorphic Environment</title>
    <style>
        body {
            margin: 0;
            overflow: hidden; /* Prevent scrollbars */
            font-family: 'Inter', sans-serif;
        }
        canvas {
            display: block; /* Remove extra space below canvas */
            width: 100vw; /* Make canvas fill viewport width */
            height: 100vh; /* Make canvas fill viewport height */
        }
        /* Styling for the instructions message */
        #instructions {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.6);
            color: white;
            padding: 10px 20px;
            border-radius: 8px;
            font-size: 1.1em;
            z-index: 10;
            text-align: center;
        }
    </style>
</head>
<body>
    <div id="instructions">
        Use **W A S D** keys to move the character.
    </div>

    <!-- Three.js library import -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        // Global variables for Three.js scene, camera, renderer, etc.
        let scene, camera, renderer, character, plane;
        let keys = { w: false, a: false, s: false, d: false }; // State for pressed keys
        const moveSpeed = 200; // Speed of the character movement (adjusted for better feel)
        const frustumSize = 1000; // Size of the orthographic camera's view frustum
        let clock = new THREE.Clock(); // For frame-rate independent movement

        // Camera trailing parameters
        const cameraFollowDampening = 0.05; // How smoothly the camera follows (0-1, lower is smoother)
        const cameraOffset = new THREE.Vector3(500, 500, 500); // Fixed offset from character for isomorphic view

        /**
         * Creates a 2D canvas with text, suitable for use as a Three.js texture.
         * @param {string} text - The text content.
         * @param {string} textColor - CSS color for the text.
         * @param {string} backgroundColor - CSS color for the background.
         * @param {number} width - Width of the canvas.
         * @param {number} height - Height of the canvas.
         * @returns {HTMLCanvasElement} - The created canvas element.
         */
        function createTextCanvas(texts, textColor, backgroundColor, width, height) {
            const canvas = document.createElement('canvas');
            canvas.width = width;
            canvas.height = height;
            const context = canvas.getContext('2d');

            // Draw background
            context.fillStyle = backgroundColor;
            context.fillRect(0, 0, width, height);

            // Draw text
            context.fillStyle = textColor;
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            
            texts.forEach(textInfo => {
                context.font = textInfo.font;
                context.fillText(textInfo.text, width / 2, textInfo.y);
            });

            return canvas;
        }

        /**
         * Creates a project card canvas with image placeholder, title, and description.
         * @param {string} title - Project title.
         * @param {string} description - Project description.
         * @param {string} imageUrl - URL to project image.
         * @param {number} width - Canvas width.
         * @param {number} height - Canvas height.
         * @returns {HTMLCanvasElement} - The created canvas element.
         */
        function createProjectCard(title, description, imageUrl, width, height) {
            const canvas = document.createElement('canvas');
            canvas.width = width;
            canvas.height = height;
            const context = canvas.getContext('2d');

            // Draw background
            context.fillStyle = 'rgba(255, 255, 255, 0.9)';
            context.fillRect(0, 0, width, height);
            
            // Draw border
            context.strokeStyle = '#333';
            context.lineWidth = 4;
            context.strokeRect(0, 0, width, height);

            // Image placeholder
            const imageHeight = height * 0.5; // Reduced from 0.6 to make room for more text
            context.fillStyle = '#ddd';
            context.fillRect(20, 20, width - 40, imageHeight - 40);
            
            // Image placeholder text
            context.fillStyle = '#666';
            context.font = 'Bold 30px Inter'; // Reduced from 40px
            context.textAlign = 'center';
            context.fillText('Project Image', width / 2, imageHeight / 2);

            // Title
            context.fillStyle = '#333';
            context.font = 'Bold 40px Inter'; // Reduced from 60px
            context.textAlign = 'center';
            context.fillText(title, width / 2, imageHeight + 35);

            // Description with scrolling text effect
            context.fillStyle = '#666';
            context.font = '24px Inter'; // Reduced from 40px
            context.textAlign = 'left'; // Changed to left align for better readability
            
            // Create scrolling text in a defined area
            const textAreaY = imageHeight + 70;
            const textAreaHeight = height - textAreaY - 20;
            const lineHeight = 30;
            const maxLines = Math.floor(textAreaHeight / lineHeight);
            
            // Word wrap for description
            const words = description.split(' ');
            const lines = [];
            let line = '';
            const maxWidth = width - 60; // More padding
            
            for (let n = 0; n < words.length; n++) {
                const testLine = line + words[n] + ' ';
                const metrics = context.measureText(testLine);
                const testWidth = metrics.width;
                if (testWidth > maxWidth && n > 0) {
                    lines.push(line.trim());
                    line = words[n] + ' ';
                } else {
                    line = testLine;
                }
            }
            if (line.trim()) {
                lines.push(line.trim());
            }

            // Draw visible lines (truncate if too many)
            const visibleLines = lines.slice(0, maxLines);
            visibleLines.forEach((textLine, index) => {
                context.fillText(textLine, 30, textAreaY + (index * lineHeight));
            });

            // Add "..." if text is truncated
            if (lines.length > maxLines) {
                context.fillText('...', 30, textAreaY + ((maxLines - 1) * lineHeight) + 25);
            }

            return canvas;
        }

        /**
         * Initializes the 3D scene, camera, renderer, and objects.
         */
        function init() {
            // 1. Scene setup
            scene = new THREE.Scene();
            // Set the background color to a darker blue to represent the lower horizon/ground blend
            scene.background = new THREE.Color(0x70a0e0); // A medium blue for the lower part of the sky/horizon

            // 2. Camera setup (Orthographic for isomorphic view)
            const aspect = window.innerWidth / window.innerHeight;
            // The orthographic camera is defined by its frustum, ensuring parallel projection.
            // Arguments: left, right, top, bottom, near, far
            camera = new THREE.OrthographicCamera(
                frustumSize * aspect / -2,  // left
                frustumSize * aspect / 2,   // right
                frustumSize / 2,            // top
                frustumSize / -2,           // bottom
                1,                          // near clipping plane
                2000                        // far clipping plane
            );
            // Initial camera position (will be updated by trailing logic)
            camera.position.set(cameraOffset.x, cameraOffset.y, cameraOffset.z);
            camera.lookAt(0, 0, 0); // Initial lookAt, will be updated

            // 3. Renderer setup
            renderer = new THREE.WebGLRenderer({ antialias: true }); // Enable antialiasing for smoother edges
            renderer.setSize(window.innerWidth, window.innerHeight); // Set renderer size to fill the window
            renderer.setPixelRatio(window.devicePixelRatio); // Handle high DPI screens
            document.body.appendChild(renderer.domElement); // Add the renderer's canvas to the DOM

            // Enable shadows in the renderer
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap; // Softer shadows

            // 4. Lighting
            // HemisphereLight: Simulates natural light from the sky and ground
            // Arguments: skyColor, groundColor, intensity
            const skyColor = new THREE.Color(0xADD8E6); // Lighter blue for the sky
            const groundColor = new THREE.Color(0x406090); // Darker blue for the ground/ambient shadow
            const hemisphereLight = new THREE.HemisphereLight(skyColor, groundColor, 0.7);
            scene.add(hemisphereLight);

            // DirectionalLight: Simulates light from a distant source (like the sun)
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8); // White light, increased intensity
            directionalLight.position.set(200, 300, 100); // Position it from top-right-front
            directionalLight.castShadow = true; // Enable shadows

            // Configure shadow camera for directional light
            directionalLight.shadow.mapSize.width = 1024; // default is 512
            directionalLight.shadow.mapSize.height = 1024; // default is 512
            directionalLight.shadow.camera.near = 0.5; // default
            directionalLight.shadow.camera.far = 500; // default
            directionalLight.shadow.camera.left = -500;
            directionalLight.shadow.camera.right = 500;
            directionalLight.shadow.camera.top = 500;
            directionalLight.shadow.camera.bottom = -500;
            scene.add(directionalLight);

            // 5. Ground Plane
            // Create a large, flat plane for the ground
            const planeGeometry = new THREE.PlaneGeometry(2000, 2000);
            // A simple grey material for the ground
            const planeMaterial = new THREE.MeshLambertMaterial({ color: 0x888888, side: THREE.DoubleSide });
            plane = new THREE.Mesh(planeGeometry, planeMaterial);
            plane.rotation.x = -Math.PI / 2; // Rotate to be flat on the XZ plane
            plane.receiveShadow = true; // Allow the plane to receive shadows
            scene.add(plane);

            // 6. Character
            // Create a simple character (e.g., a red box)
            const characterGeometry = new THREE.BoxGeometry(50, 100, 50); // Width, Height, Depth
            const characterMaterial = new THREE.MeshLambertMaterial({ color: 0xff0000 }); // Red color
            character = new THREE.Mesh(characterGeometry, characterMaterial);
            character.position.y = 50; // Position it slightly above the plane so it doesn't sink
            character.castShadow = true; // Allow the character to cast shadows
            scene.add(character);

            // 7. Text Overlays on Floor
            const textPlaneWidth = 2000;

            // Mason's Projects Header (above donut)
            const masonHeaderCanvas = createTextCanvas(
                [{ text: "Mason's Projects:", font: 'Bold 120px Inter', y: 100 }], '#FFD700', 'rgba(0,0,0,0.5)',
                textPlaneWidth, 200
            );
            const masonHeaderTexture = new THREE.CanvasTexture(masonHeaderCanvas);
            const masonHeaderMaterial = new THREE.MeshBasicMaterial({ map: masonHeaderTexture, transparent: true, side: THREE.DoubleSide });
            const masonHeaderPlane = new THREE.Mesh(new THREE.PlaneGeometry(textPlaneWidth, 200), masonHeaderMaterial);
            masonHeaderPlane.rotation.x = -Math.PI / 2;
            masonHeaderPlane.position.z = -400; // Above donut, in Mason's area
            masonHeaderPlane.position.y = 0.1;
            scene.add(masonHeaderPlane);

            // Center text plane (donut)
            const amongusCanvas = createTextCanvas(
                [{ text: "donut", font: 'Bold 150px Inter', y: 100 }], '#FFFFFF', 'rgba(0,0,0,0.7)', // White text, more opaque background
                textPlaneWidth, 200 // Shorter height for the center text
            );
            const amongusTexture = new THREE.CanvasTexture(amongusCanvas);
            const amongusMaterial = new THREE.MeshBasicMaterial({ map: amongusTexture, transparent: true, side: THREE.DoubleSide });
            const amongusPlane = new THREE.Mesh(new THREE.PlaneGeometry(textPlaneWidth, 200), amongusMaterial);
            amongusPlane.rotation.x = -Math.PI / 2; // Lay flat
            amongusPlane.position.z = 0; // Centered between Mason and Tyson
            amongusPlane.position.y = 0.11; // Slightly above the other planes to prevent z-fighting
            scene.add(amongusPlane);

            // Tyson's Projects Header (below donut)
            const tysonHeaderCanvas = createTextCanvas(
                [{ text: "Tyson's Projects:", font: 'Bold 120px Inter', y: 100 }], '#00FFFF', 'rgba(0,0,0,0.5)',
                textPlaneWidth, 200
            );
            const tysonHeaderTexture = new THREE.CanvasTexture(tysonHeaderCanvas);
            const tysonHeaderMaterial = new THREE.MeshBasicMaterial({ map: tysonHeaderTexture, transparent: true, side: THREE.DoubleSide });
            const tysonHeaderPlane = new THREE.Mesh(new THREE.PlaneGeometry(textPlaneWidth, 200), tysonHeaderMaterial);
            tysonHeaderPlane.rotation.x = -Math.PI / 2;
            tysonHeaderPlane.position.z = 400; // Below donut, in Tyson's area
            tysonHeaderPlane.position.y = 0.1;
            scene.add(tysonHeaderPlane);

            // 8. Project Cards
            const cardWidth = 400;
            const cardHeight = 500;

            // Mason's Project Cards
            const masonProject1Canvas = createProjectCard(
                "Awesome Game",
                "An innovative 3D adventure game with stunning graphics and immersive gameplay mechanics.",
                "",
                cardWidth,
                cardHeight
            );
            const masonProject1Texture = new THREE.CanvasTexture(masonProject1Canvas);
            const masonProject1Material = new THREE.MeshBasicMaterial({ map: masonProject1Texture, transparent: true });
            const masonProject1Plane = new THREE.Mesh(new THREE.PlaneGeometry(cardWidth, cardHeight), masonProject1Material);
            masonProject1Plane.rotation.x = -Math.PI / 2;
            masonProject1Plane.position.set(-300, 0.12, -600);
            masonProject1Plane.userData = { type: 'projectCard', url: 'https://github.com/mason/awesome-game' };
            scene.add(masonProject1Plane);

            const masonProject2Canvas = createProjectCard(
                "Cool Website",
                "A responsive modern website built with cutting-edge technologies and beautiful design.",
                "",
                cardWidth,
                cardHeight
            );
            const masonProject2Texture = new THREE.CanvasTexture(masonProject2Canvas);
            const masonProject2Material = new THREE.MeshBasicMaterial({ map: masonProject2Texture, transparent: true });
            const masonProject2Plane = new THREE.Mesh(new THREE.PlaneGeometry(cardWidth, cardHeight), masonProject2Material);
            masonProject2Plane.rotation.x = -Math.PI / 2;
            masonProject2Plane.position.set(300, 0.12, -600);
            masonProject2Plane.userData = { type: 'projectCard', url: 'https://github.com/mason/cool-website' };
            scene.add(masonProject2Plane);

            // Tyson's Project Cards
            const tysonProject1Canvas = createProjectCard(
                "AI Assistant",
                "An intelligent AI-powered assistant that helps users with various tasks and provides smart recommendations.",
                "",
                cardWidth,
                cardHeight
            );
            const tysonProject1Texture = new THREE.CanvasTexture(tysonProject1Canvas);
            const tysonProject1Material = new THREE.MeshBasicMaterial({ map: tysonProject1Texture, transparent: true });
            const tysonProject1Plane = new THREE.Mesh(new THREE.PlaneGeometry(cardWidth, cardHeight), tysonProject1Material);
            tysonProject1Plane.rotation.x = -Math.PI / 2;
            tysonProject1Plane.position.set(-300, 0.12, 600);
            tysonProject1Plane.userData = { type: 'projectCard', url: 'https://github.com/tyson/ai-assistant' };
            scene.add(tysonProject1Plane);

            const tysonProject2Canvas = createProjectCard(
                "Data Visualizer",
                "A powerful tool for creating interactive data visualizations and insightful analytics dashboards.",
                "",
                cardWidth,
                cardHeight
            );
            const tysonProject2Texture = new THREE.CanvasTexture(tysonProject2Canvas);
            const tysonProject2Material = new THREE.MeshBasicMaterial({ map: tysonProject2Texture, transparent: true });
            const tysonProject2Plane = new THREE.Mesh(new THREE.PlaneGeometry(cardWidth, cardHeight), tysonProject2Material);
            tysonProject2Plane.rotation.x = -Math.PI / 2;
            tysonProject2Plane.position.set(300, 0.12, 600);
            tysonProject2Plane.userData = { type: 'projectCard', url: 'https://github.com/tyson/data-visualizer' };
            scene.add(tysonProject2Plane);

            // 9. Mouse Interaction for Project Cards
            const raycaster = new THREE.Raycaster();
            const mouse = new THREE.Vector2();
            const projectCards = [masonProject1Plane, masonProject2Plane, tysonProject1Plane, tysonProject2Plane];

            function onMouseClick(event) {
                // Calculate mouse position in normalized device coordinates
                mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

                // Update the raycaster with the camera and mouse position
                raycaster.setFromCamera(mouse, camera);

                // Calculate objects intersecting the ray
                const intersects = raycaster.intersectObjects(projectCards);

                if (intersects.length > 0) {
                    const clickedObject = intersects[0].object;
                    if (clickedObject.userData.type === 'projectCard' && clickedObject.userData.url) {
                        window.open(clickedObject.userData.url, '_blank');
                    }
                }
            }

            function onMouseMove(event) {
                // Calculate mouse position for hover effects
                mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObjects(projectCards);

                // Reset all cards to normal scale
                projectCards.forEach(card => {
                    card.scale.set(1, 1, 1);
                });

                // Scale up hovered card
                if (intersects.length > 0) {
                    document.body.style.cursor = 'pointer';
                    intersects[0].object.scale.set(1.1, 1.1, 1.1);
                } else {
                    document.body.style.cursor = 'default';
                }
            }

            // Add mouse event listeners
            document.addEventListener('click', onMouseClick);
            document.addEventListener('mousemove', onMouseMove);

            // 10. YouTube Video Pedestal Display (right side of scene)
            const videoWidth = 220;
            const videoHeight = 124;
            const pedestalHeight = 120;
            const pedestalRadius = 90;

            // Create a pedestal (cylinder)
            const pedestalGeometry = new THREE.CylinderGeometry(pedestalRadius, pedestalRadius, pedestalHeight, 32);
            const pedestalMaterial = new THREE.MeshLambertMaterial({ color: 0xcccccc });
            const pedestal = new THREE.Mesh(pedestalGeometry, pedestalMaterial);
            pedestal.position.set(700, pedestalHeight / 2, 0);
            scene.add(pedestal);

            // Create the iframe for the YouTube video (smaller size)
            const youtubeIframe = document.createElement('iframe');
            youtubeIframe.src = 'https://www.youtube.com/embed/apYvMDs31bA?start=138&autoplay=0&mute=1&controls=1';
            youtubeIframe.width = videoWidth;
            youtubeIframe.height = videoHeight;
            youtubeIframe.style.border = 'none';
            youtubeIframe.allow = 'accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share';
            youtubeIframe.allowFullscreen = true;
            youtubeIframe.style.position = 'absolute';
            youtubeIframe.style.zIndex = '20';
            document.body.appendChild(youtubeIframe);

            // Update the iframe position to match the top of the pedestal
            function updateIframePosition() {
                // 3D position at the top center of the pedestal
                const vector = new THREE.Vector3(700, pedestalHeight + videoHeight / 8, 0);
                vector.project(camera);
                const x = (vector.x * 0.5 + 0.5) * window.innerWidth - videoWidth / 2;
                const y = (-vector.y * 0.5 + 0.5) * window.innerHeight - videoHeight / 2;
                youtubeIframe.style.left = `${x}px`;
                youtubeIframe.style.top = `${y}px`;
            }

            // Call updateIframePosition on each render
            const originalAnimate = animate;
            function animateWithIframe() {
                originalAnimate();
                updateIframePosition();
            }
            animate = animateWithIframe;

            window.addEventListener('resize', updateIframePosition);

            // 11. Event Listeners
            // Listen for keyboard input for movement
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            // Listen for window resize events to update camera and renderer
            window.addEventListener('resize', onWindowResize);
        }

        /**
         * Handles window resizing, updating camera aspect ratio and renderer size.
         */
        function onWindowResize() {
            const aspect = window.innerWidth / window.innerHeight;
            // Update camera frustum based on new aspect ratio
            camera.left = frustumSize * aspect / -2;
            camera.right = frustumSize * aspect / 2;
            camera.top = frustumSize / 2;
            camera.bottom = frustumSize / -2;
            camera.updateProjectionMatrix(); // Recalculate projection matrix
            renderer.setSize(window.innerWidth, window.innerHeight); // Resize renderer
        }

        /**
         * Handles keydown events to set movement flags.
         * @param {KeyboardEvent} event - The keyboard event.
         */
        function onKeyDown(event) {
            switch (event.code) {
                case 'KeyW':
                    keys.w = true;
                    break;
                case 'KeyA':
                    keys.a = true;
                    break;
                case 'KeyS':
                    keys.s = true;
                    break;
                case 'KeyD':
                    keys.d = true;
                    break;
            }
        }

        /**
         * Handles keyup events to clear movement flags.
         * @param {KeyboardEvent} event - The keyboard event.
         */
        function onKeyUp(event) {
            switch (event.code) {
                case 'KeyW':
                    keys.w = false;
                    break;
                case 'KeyA':
                    keys.a = false;
                    break;
                case 'KeyS':
                    keys.s = false;
                    break;
                case 'KeyD':
                    keys.d = false;
                    break;
            }
        }

        /**
         * The animation loop, continuously updates the scene and renders.
         */
        function animate() {
            requestAnimationFrame(animate); // Request the next frame

            const deltaTime = clock.getDelta(); // Time elapsed since last frame

            // Update character position based on pressed keys
            if (character) {
                if (keys.w) {
                    character.position.z -= moveSpeed * deltaTime; // Move backward in Z (forward in view)
                }
                if (keys.s) {
                    character.position.z += moveSpeed * deltaTime; // Move forward in Z (backward in view)
                }
                if (keys.a) {
                    character.position.x -= moveSpeed * deltaTime; // Move left in X
                }
                if (keys.d) {
                    character.position.x += moveSpeed * deltaTime; // Move right in X
                }

                // Optional: Clamp character position to stay within the plane
                const halfPlaneSize = 1000 / 2 - 25; // Plane size / 2 - half character size
                character.position.x = Math.max(-halfPlaneSize, Math.min(halfPlaneSize, character.position.x));
                character.position.z = Math.max(-halfPlaneSize, Math.min(halfPlaneSize, character.position.z));

                // Camera Trailing Logic
                // Calculate the target camera position
                const targetCameraPosition = new THREE.Vector3().copy(character.position).add(cameraOffset);

                // Smoothly interpolate camera's current position towards the target position
                camera.position.lerp(targetCameraPosition, cameraFollowDampening);

                // Make the camera look at the character's position
                camera.lookAt(character.position);
            }

            renderer.render(scene, camera); // Render the scene
        }

        // Initialize the scene when the window loads
        window.onload = function() {
            init();
            animate(); // Start the animation loop
        };
    </script>
</body>
</html>
